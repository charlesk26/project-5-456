---
title: "Predicting Malignant or Benign Cells in Breast Tissue"
author: "Group 1"
date: "`r Sys.Date()`"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Packages
```{r, include=FALSE}
library(dplyr)
library(reshape2)
library(corrplot)
library(caret)
library(pROC)
library(gridExtra)
library(grid)
library(ggfortify)
library(purrr)
library(nnet)
library(doParallel) # parallel processing
registerDoParallel()
require(foreach)
require(iterators)
require(parallel)
#others I had before
library(tibble)
library(cvms)
library(GGally)
library(plotly)
library(dplyr)
library(class)
library(moderndive)
library(skimr)
library(infer)
library(tinytex)
library(MASS)
library(caret)
library(gmodels)
library(tidyverse)  # data manipulation
library(cluster)    # clustering algorithms
library(factoextra) # clustering algorithms & visualization
```
#Load in Data
```{r}
df <- read.csv("~/Documents/Collegiate/Spring_2022/MATH_456/essays/project_5/data/breast_cancer/wdbc.data.csv")
numeric <- subset(df, select = -c(id,diagnosis))
s_df <- scale(numeric)
```
#Understand orriginal data
```{r}
#Break up columns into groups, according to their suffix designation 
#(_mean, _se,and __worst) to perform visualisation plots off.
data_mean <- subset(df, select = c(diagnosis, radius_mean, texture_mean,perimeter_mean, area_mean, smoothness_mean, compactness_mean, concavity_mean, concave.points_mean, symmetry_mean, fractal_dimension_mean))

data_se <- subset(df, select = c("diagnosis", "radius_se", "texture_se","perimeter_se", "area_se", "smoothness_se", "compactness_se", "concavity_se", "concave.points_se", "symmetry_se", "fractal_dimension_se" ))

data_worst <-subset(df, select = c("diagnosis", "radius_worst", "texture_worst","perimeter_worst", "area_worst", "smoothness_worst", "compactness_worst", "concavity_worst", "concave.points_worst", "symmetry_worst", "fractal_dimension_worst" ))

#Plot histograms of "_mean" variables group by diagnosis
ggplot(data = melt(data_mean, id.var = "diagnosis"), mapping = aes(x = value)) + 
    geom_histogram(bins = 10, aes(fill=diagnosis), alpha=0.5) + facet_wrap(~variable, scales =      'free_x')
#Plot histograms of "_se" variables group by diagnosis
ggplot(data = melt(data_se, id.var = "diagnosis"), mapping = aes(x = value)) + 
    geom_histogram(bins = 10, aes(fill=diagnosis), alpha=0.5) + facet_wrap(~variable, scales = 'free_x')
#Plot histograms of "_worst" variables group by diagnosis
ggplot(data = melt(data_worst, id.var = "diagnosis"), mapping = aes(x = value)) + 
    geom_histogram(bins = 10, aes(fill=diagnosis), alpha=0.5) + facet_wrap(~variable, scales = 'free_x')
```
#Bivariate/multivariate analysis
```{r}
# calculate collinearity
bc_data <- df[,-c(0:1)]
#Remove the last column
bc_data <- bc_data[,-32]
#Tidy the data
bc_data$diagnosis <- as.factor(bc_data$diagnosis)
corMatMy <- cor(bc_data[,2:31])
corrplot(corMatMy, order = "hclust", tl.cex = 0.7)
```
#PCA
```{r}
pca <- prcomp(numeric, scale = TRUE)
# print(pca)
pca.var <- pca$sdev^2
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
pca.var.per
df$pc1 <- pca$x[,1]
df$pc2 <- pca$x[,2]
df$pc3 <- pca$x[,3]
df$pc4 <- pca$x[,4]
PC_df <- data.frame(PC = 1:30, var_explained = pca.var.per)
```
#First two principle_componenets
```{r}
ggplot(df, aes(x = pc1, y = pc2, color = diagnosis))+geom_point(alpha = 0.6)
ggplot(PC_df, aes(x = PC, y = var_explained))+geom_col()+labs(x = 'Principal Component', y = 'percent variance explained', title = 'PCA Scree Plot')
```
#First three principle components
```{r}
p <- plot_ly(
  df, x = ~pc1, y = ~pc2, z = ~pc3, 
  color = ~diagnosis, colors = c('#f2746b', '#5fb1d4')
  ) %>%
  add_markers() %>%
  layout(
    scene = list(xaxis = list(title = 'PC 1'),
        yaxis = list(title = 'PC 2'),
        zaxis = list(title = 'PC 3'))
        )
p
```
#PC 2-4
```{r}
p <- plot_ly(
  df, x = ~pc2, y = ~pc3, z = ~pc4, 
  color = ~diagnosis, colors = c('#f2746b', '#5fb1d4')
  ) %>%
  add_markers() %>%
  layout(
    scene = list(xaxis = list(title = 'PC 2'),
        yaxis = list(title = 'PC 3'),
        zaxis = list(title = 'PC 4'))
        )
p
```
#Visualize Distance
```{r}
distance <- get_dist(s_df)
fviz_dist(distance, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
```
#Cluster k = 2
```{r}
k2 <- kmeans(s_df, centers = 2, nstart = 25)
str(k2)
k2
```
#Visualize Cluster
```{r}
fviz_cluster(k2, data = s_df)
```
#Other K's
```{r}
k3 <- kmeans(s_df, centers = 3, nstart = 25)
k4 <- kmeans(s_df, centers = 4, nstart = 25)
k5 <- kmeans(s_df, centers = 5, nstart = 25)

# plots to compare
p1 <- fviz_cluster(k2, geom = "point", data = s_df) + ggtitle("k = 2")
p2 <- fviz_cluster(k3, geom = "point",  data = s_df) + ggtitle("k = 3")
p3 <- fviz_cluster(k4, geom = "point",  data = s_df) + ggtitle("k = 4")
p4 <- fviz_cluster(k5, geom = "point",  data = s_df) + ggtitle("k = 5")

library(gridExtra)
grid.arrange(p1, p2, p3, p4, nrow = 2)
```
#Determining Best Number of Clusters
```{r}
set.seed(123)

# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(s_df, k, nstart = 25)$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

plot(k.values, wss_values,
       type="b", pch = 19, frame = FALSE, 
       xlab="Number of clusters K",
       ylab="Total within-clusters sum of squares")
set.seed(123)

fviz_nbclust(s_df, kmeans, method = "wss")
```
#Average Sillhouette
```{r}
# function to compute average silhouette for k clusters
avg_sil <- function(k) {
  km.res <- kmeans(s_df, centers = k, nstart = 25)
  ss <- silhouette(km.res$cluster, dist(s_df))
  mean(ss[, 3])
}

# Compute and plot wss for k = 2 to k = 15
k.values <- 2:15

# extract avg silhouette for 2-15 clusters
avg_sil_values <- map_dbl(k.values, avg_sil)

plot(k.values, avg_sil_values,
       type = "b", pch = 19, frame = FALSE, 
       xlab = "Number of clusters K",
       ylab = "Average Silhouettes")
fviz_nbclust(s_df, kmeans, method = "silhouette")
```
#Gap Statiscit Method
```{r}
# compute gap statistic
set.seed(123)
gap_stat <- clusGap(s_df, FUN = kmeans, nstart = 25,
                    K.max = 10, B = 50)
# Print the result
print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
```
#Final
```{r}
# Compute k-means clustering with k = 4
set.seed(123)
final <- kmeans(s_df, 2, nstart = 25)
print(final)
fviz_cluster(final, data = s_df)
str(final$cluster)
```
```{r}
results_df <- data.frame(actual = ifelse(df$diagnosis == "B", 'Benign', 'Malignant'), predicted = ifelse(final$cluster == 2, 'Benign', 'Malignant')) #benign is cluster 2 Malginant is cluster 1
head(results_df)
cm <- confusionMatrix(factor(results_df$actual), factor(results_df$predicted), dnn = c("Prediction", "Reference"))

plt <- as.data.frame(cm$table)
plt$Prediction <- factor(plt$Prediction, levels=rev(levels(plt$Prediction)))

ggplot(plt, aes(Prediction,Reference, fill= Freq)) +
        geom_tile() + geom_text(aes(label=Freq)) +
        scale_fill_gradient(low="white", high="#009194") +
        labs(x = "Actual Outcome",y = "Prediction From Clusters") +
        scale_x_discrete(labels=c("Malignant","Benign")) +
        scale_y_discrete(labels=c("Benign", "Malignant"))
```
#Visualize Prediction
```{r}
df$outcomes = ifelse(results_df$actual == results_df$predicted, ifelse(results_df$actual == 'Benign', 'True Negative', 'True Positive'), ifelse(results_df$predicted == 'Malignant', 'False Positive', 'False Negative'))
df$predictions = results_df$predicted

ggplot(df, aes(x = pc1, y = pc2, color = outcomes))+geom_point(alpha = 0.6)+labs(title = 'Actual Diagnosis vs groupings')
```
#First three principle components outcomes
```{r}
p <- plot_ly(
  df, x = ~pc1, y = ~pc2, z = ~pc3, 
  color = ~outcomes
  ) %>%
  add_markers() %>%
  layout(
    scene = list(xaxis = list(title = 'PC 1'),
        yaxis = list(title = 'PC 2'),
        zaxis = list(title = 'PC 3'))
        )
p
```
#Calculate Accuracy, precision recall, f1
```{r}
tp <- sum(df$outcomes == 'True Positive')
tn <- sum(df$outcomes == 'True Negative')
fp <- sum(df$outcomes == 'False Positive')
fn <- sum(df$outcomes == 'False Negative')
tp
tn
fp
fn
acc <- (tp+tn)/(tp+tn+fp+fn)
precision <- (tp)/(tp+fn)
recall <- (tn)/(tn+fp)
acc
precision
recall
f1 <- 2 * ((precision * recall) / (precision + recall))
f1
```
